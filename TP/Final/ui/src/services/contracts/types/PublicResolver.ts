/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "./common";

export interface PublicResolverInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "ABI"
      | "addr"
      | "authorisations"
      | "contenthash"
      | "interfaceImplementer"
      | "name"
      | "pubkey"
      | "setABI"
      | "setAddr"
      | "setContenthash"
      | "setInterface"
      | "setName"
      | "setPubkey"
      | "setText"
      | "text"
      | "setAuthorisation"
      | "supportsInterface"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "ABIChanged"
      | "AddrChanged"
      | "AuthorisationChanged"
      | "ContenthashChanged"
      | "InterfaceChanged"
      | "NameChanged"
      | "PubkeyChanged"
      | "TextChanged"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "ABI",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "addr", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "authorisations",
    values: [BytesLike, AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "contenthash",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "interfaceImplementer",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "name", values: [BytesLike]): string;
  encodeFunctionData(functionFragment: "pubkey", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "setABI",
    values: [BytesLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setAddr",
    values: [BytesLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setContenthash",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setInterface",
    values: [BytesLike, BytesLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setName",
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "setPubkey",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setText",
    values: [BytesLike, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "text",
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "setAuthorisation",
    values: [BytesLike, AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [BytesLike]
  ): string;

  decodeFunctionResult(functionFragment: "ABI", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "addr", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "authorisations",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "contenthash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "interfaceImplementer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "name", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pubkey", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setABI", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setAddr", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setContenthash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setName", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setPubkey", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setText", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "text", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setAuthorisation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
}

export namespace ABIChangedEvent {
  export type InputTuple = [node: BytesLike, contentType: BigNumberish];
  export type OutputTuple = [node: string, contentType: bigint];
  export interface OutputObject {
    node: string;
    contentType: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace AddrChangedEvent {
  export type InputTuple = [node: BytesLike, a: AddressLike];
  export type OutputTuple = [node: string, a: string];
  export interface OutputObject {
    node: string;
    a: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace AuthorisationChangedEvent {
  export type InputTuple = [
    node: BytesLike,
    owner: AddressLike,
    target: AddressLike,
    isAuthorised: boolean
  ];
  export type OutputTuple = [
    node: string,
    owner: string,
    target: string,
    isAuthorised: boolean
  ];
  export interface OutputObject {
    node: string;
    owner: string;
    target: string;
    isAuthorised: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ContenthashChangedEvent {
  export type InputTuple = [node: BytesLike, hash: BytesLike];
  export type OutputTuple = [node: string, hash: string];
  export interface OutputObject {
    node: string;
    hash: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace InterfaceChangedEvent {
  export type InputTuple = [
    node: BytesLike,
    interfaceID: BytesLike,
    implementer: AddressLike
  ];
  export type OutputTuple = [
    node: string,
    interfaceID: string,
    implementer: string
  ];
  export interface OutputObject {
    node: string;
    interfaceID: string;
    implementer: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace NameChangedEvent {
  export type InputTuple = [node: BytesLike, name: string];
  export type OutputTuple = [node: string, name: string];
  export interface OutputObject {
    node: string;
    name: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace PubkeyChangedEvent {
  export type InputTuple = [node: BytesLike, x: BytesLike, y: BytesLike];
  export type OutputTuple = [node: string, x: string, y: string];
  export interface OutputObject {
    node: string;
    x: string;
    y: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace TextChangedEvent {
  export type InputTuple = [node: BytesLike, indexedKey: string, key: string];
  export type OutputTuple = [node: string, indexedKey: string, key: string];
  export interface OutputObject {
    node: string;
    indexedKey: string;
    key: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface PublicResolver extends BaseContract {
  connect(runner?: ContractRunner | null): PublicResolver;
  waitForDeployment(): Promise<this>;

  interface: PublicResolverInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  /**
   * Returns the ABI associated with an ENS node. Defined in EIP205.
   * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.
   * @param node The ENS node to query
   */
  ABI: TypedContractMethod<
    [node: BytesLike, contentTypes: BigNumberish],
    [[bigint, string]],
    "view"
  >;

  /**
   * Returns the address associated with an ENS node.
   * @param node The ENS node to query.
   */
  addr: TypedContractMethod<[node: BytesLike], [string], "view">;

  /**
   * A mapping of authorisations. An address that is authorised for a name may make any changes to the name that the owner could, but may not update the set of authorisations. (node, owner, caller) => isAuthorised
   */
  authorisations: TypedContractMethod<
    [arg0: BytesLike, arg1: AddressLike, arg2: AddressLike],
    [boolean],
    "view"
  >;

  /**
   * Returns the contenthash associated with an ENS node.
   * @param node The ENS node to query.
   */
  contenthash: TypedContractMethod<[node: BytesLike], [string], "view">;

  /**
   * Returns the address of a contract that implements the specified interface for this name. If an implementer has not been set for this interfaceID and name, the resolver will query the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that contract implements EIP168 and returns `true` for the specified interfaceID, its address will be returned.
   * @param interfaceID The EIP 168 interface ID to check for.
   * @param node The ENS node to query.
   */
  interfaceImplementer: TypedContractMethod<
    [node: BytesLike, interfaceID: BytesLike],
    [string],
    "view"
  >;

  /**
   * Returns the name associated with an ENS node, for reverse records. Defined in EIP181.
   * @param node The ENS node to query.
   */
  name: TypedContractMethod<[node: BytesLike], [string], "view">;

  /**
   * Returns the SECP256k1 public key associated with an ENS node. Defined in EIP 619.
   * @param node The ENS node to query
   */
  pubkey: TypedContractMethod<[node: BytesLike], [[string, string]], "view">;

  /**
   * Sets the ABI associated with an ENS node. Nodes may have one ABI of each content type. To remove an ABI, set it to the empty string.
   * @param contentType The content type of the ABI
   * @param data The ABI data.
   * @param node The node to update.
   */
  setABI: TypedContractMethod<
    [node: BytesLike, contentType: BigNumberish, data: BytesLike],
    [void],
    "nonpayable"
  >;

  /**
   * Sets the address associated with an ENS node. May only be called by the owner of that node in the ENS registry.
   * @param node The node to update.
   * @param nodeAddr The address to set.
   */
  setAddr: TypedContractMethod<
    [node: BytesLike, nodeAddr: AddressLike],
    [void],
    "nonpayable"
  >;

  /**
   * Sets the contenthash associated with an ENS node. May only be called by the owner of that node in the ENS registry.
   * @param hash The contenthash to set
   * @param node The node to update.
   */
  setContenthash: TypedContractMethod<
    [node: BytesLike, hash: BytesLike],
    [void],
    "nonpayable"
  >;

  /**
   * Sets an interface associated with a name. Setting the address to 0 restores the default behaviour of querying the contract at `addr()` for interface support.
   * @param implementer The address of a contract that implements this interface for this node.
   * @param interfaceID The EIP 168 interface ID.
   * @param node The node to update.
   */
  setInterface: TypedContractMethod<
    [node: BytesLike, interfaceID: BytesLike, implementer: AddressLike],
    [void],
    "nonpayable"
  >;

  /**
   * Sets the name associated with an ENS node, for reverse records. May only be called by the owner of that node in the ENS registry.
   * @param node The node to update.
   * @param nodeName The name to set.
   */
  setName: TypedContractMethod<
    [node: BytesLike, nodeName: string],
    [void],
    "nonpayable"
  >;

  /**
   * Sets the SECP256k1 public key associated with an ENS node.
   * @param node The ENS node to query
   * @param x the X coordinate of the curve point for the public key.
   * @param y the Y coordinate of the curve point for the public key.
   */
  setPubkey: TypedContractMethod<
    [node: BytesLike, x: BytesLike, y: BytesLike],
    [void],
    "nonpayable"
  >;

  /**
   * Sets the text data associated with an ENS node and key. May only be called by the owner of that node in the ENS registry.
   * @param key The key to set.
   * @param node The node to update.
   * @param value The text data value to set.
   */
  setText: TypedContractMethod<
    [node: BytesLike, key: string, value: string],
    [void],
    "nonpayable"
  >;

  /**
   * Returns the text data associated with an ENS node and key.
   * @param key The text data key to query.
   * @param node The ENS node to query.
   */
  text: TypedContractMethod<[node: BytesLike, key: string], [string], "view">;

  /**
   * Sets or clears an authorisation. Authorisations are specific to the caller. Any account can set an authorisation for any name, but the authorisation that is checked will be that of the current owner of a name. Thus, transferring a name effectively clears any existing authorisations, and new authorisations can be set in advance of an ownership transfer if desired.
   * @param authorize True if the address should be authorised, or false if it should be deauthorised.
   * @param node The name to change the authorisation on.
   * @param target The address that is to be authorised or deauthorised.
   */
  setAuthorisation: TypedContractMethod<
    [node: BytesLike, target: AddressLike, authorize: boolean],
    [void],
    "nonpayable"
  >;

  supportsInterface: TypedContractMethod<
    [interfaceID: BytesLike],
    [boolean],
    "view"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "ABI"
  ): TypedContractMethod<
    [node: BytesLike, contentTypes: BigNumberish],
    [[bigint, string]],
    "view"
  >;
  getFunction(
    nameOrSignature: "addr"
  ): TypedContractMethod<[node: BytesLike], [string], "view">;
  getFunction(
    nameOrSignature: "authorisations"
  ): TypedContractMethod<
    [arg0: BytesLike, arg1: AddressLike, arg2: AddressLike],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "contenthash"
  ): TypedContractMethod<[node: BytesLike], [string], "view">;
  getFunction(
    nameOrSignature: "interfaceImplementer"
  ): TypedContractMethod<
    [node: BytesLike, interfaceID: BytesLike],
    [string],
    "view"
  >;
  getFunction(
    nameOrSignature: "name"
  ): TypedContractMethod<[node: BytesLike], [string], "view">;
  getFunction(
    nameOrSignature: "pubkey"
  ): TypedContractMethod<[node: BytesLike], [[string, string]], "view">;
  getFunction(
    nameOrSignature: "setABI"
  ): TypedContractMethod<
    [node: BytesLike, contentType: BigNumberish, data: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setAddr"
  ): TypedContractMethod<
    [node: BytesLike, nodeAddr: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setContenthash"
  ): TypedContractMethod<
    [node: BytesLike, hash: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setInterface"
  ): TypedContractMethod<
    [node: BytesLike, interfaceID: BytesLike, implementer: AddressLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setName"
  ): TypedContractMethod<
    [node: BytesLike, nodeName: string],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setPubkey"
  ): TypedContractMethod<
    [node: BytesLike, x: BytesLike, y: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setText"
  ): TypedContractMethod<
    [node: BytesLike, key: string, value: string],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "text"
  ): TypedContractMethod<[node: BytesLike, key: string], [string], "view">;
  getFunction(
    nameOrSignature: "setAuthorisation"
  ): TypedContractMethod<
    [node: BytesLike, target: AddressLike, authorize: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "supportsInterface"
  ): TypedContractMethod<[interfaceID: BytesLike], [boolean], "view">;

  getEvent(
    key: "ABIChanged"
  ): TypedContractEvent<
    ABIChangedEvent.InputTuple,
    ABIChangedEvent.OutputTuple,
    ABIChangedEvent.OutputObject
  >;
  getEvent(
    key: "AddrChanged"
  ): TypedContractEvent<
    AddrChangedEvent.InputTuple,
    AddrChangedEvent.OutputTuple,
    AddrChangedEvent.OutputObject
  >;
  getEvent(
    key: "AuthorisationChanged"
  ): TypedContractEvent<
    AuthorisationChangedEvent.InputTuple,
    AuthorisationChangedEvent.OutputTuple,
    AuthorisationChangedEvent.OutputObject
  >;
  getEvent(
    key: "ContenthashChanged"
  ): TypedContractEvent<
    ContenthashChangedEvent.InputTuple,
    ContenthashChangedEvent.OutputTuple,
    ContenthashChangedEvent.OutputObject
  >;
  getEvent(
    key: "InterfaceChanged"
  ): TypedContractEvent<
    InterfaceChangedEvent.InputTuple,
    InterfaceChangedEvent.OutputTuple,
    InterfaceChangedEvent.OutputObject
  >;
  getEvent(
    key: "NameChanged"
  ): TypedContractEvent<
    NameChangedEvent.InputTuple,
    NameChangedEvent.OutputTuple,
    NameChangedEvent.OutputObject
  >;
  getEvent(
    key: "PubkeyChanged"
  ): TypedContractEvent<
    PubkeyChangedEvent.InputTuple,
    PubkeyChangedEvent.OutputTuple,
    PubkeyChangedEvent.OutputObject
  >;
  getEvent(
    key: "TextChanged"
  ): TypedContractEvent<
    TextChangedEvent.InputTuple,
    TextChangedEvent.OutputTuple,
    TextChangedEvent.OutputObject
  >;

  filters: {
    "ABIChanged(bytes32,uint256)": TypedContractEvent<
      ABIChangedEvent.InputTuple,
      ABIChangedEvent.OutputTuple,
      ABIChangedEvent.OutputObject
    >;
    ABIChanged: TypedContractEvent<
      ABIChangedEvent.InputTuple,
      ABIChangedEvent.OutputTuple,
      ABIChangedEvent.OutputObject
    >;

    "AddrChanged(bytes32,address)": TypedContractEvent<
      AddrChangedEvent.InputTuple,
      AddrChangedEvent.OutputTuple,
      AddrChangedEvent.OutputObject
    >;
    AddrChanged: TypedContractEvent<
      AddrChangedEvent.InputTuple,
      AddrChangedEvent.OutputTuple,
      AddrChangedEvent.OutputObject
    >;

    "AuthorisationChanged(bytes32,address,address,bool)": TypedContractEvent<
      AuthorisationChangedEvent.InputTuple,
      AuthorisationChangedEvent.OutputTuple,
      AuthorisationChangedEvent.OutputObject
    >;
    AuthorisationChanged: TypedContractEvent<
      AuthorisationChangedEvent.InputTuple,
      AuthorisationChangedEvent.OutputTuple,
      AuthorisationChangedEvent.OutputObject
    >;

    "ContenthashChanged(bytes32,bytes)": TypedContractEvent<
      ContenthashChangedEvent.InputTuple,
      ContenthashChangedEvent.OutputTuple,
      ContenthashChangedEvent.OutputObject
    >;
    ContenthashChanged: TypedContractEvent<
      ContenthashChangedEvent.InputTuple,
      ContenthashChangedEvent.OutputTuple,
      ContenthashChangedEvent.OutputObject
    >;

    "InterfaceChanged(bytes32,bytes4,address)": TypedContractEvent<
      InterfaceChangedEvent.InputTuple,
      InterfaceChangedEvent.OutputTuple,
      InterfaceChangedEvent.OutputObject
    >;
    InterfaceChanged: TypedContractEvent<
      InterfaceChangedEvent.InputTuple,
      InterfaceChangedEvent.OutputTuple,
      InterfaceChangedEvent.OutputObject
    >;

    "NameChanged(bytes32,string)": TypedContractEvent<
      NameChangedEvent.InputTuple,
      NameChangedEvent.OutputTuple,
      NameChangedEvent.OutputObject
    >;
    NameChanged: TypedContractEvent<
      NameChangedEvent.InputTuple,
      NameChangedEvent.OutputTuple,
      NameChangedEvent.OutputObject
    >;

    "PubkeyChanged(bytes32,bytes32,bytes32)": TypedContractEvent<
      PubkeyChangedEvent.InputTuple,
      PubkeyChangedEvent.OutputTuple,
      PubkeyChangedEvent.OutputObject
    >;
    PubkeyChanged: TypedContractEvent<
      PubkeyChangedEvent.InputTuple,
      PubkeyChangedEvent.OutputTuple,
      PubkeyChangedEvent.OutputObject
    >;

    "TextChanged(bytes32,string,string)": TypedContractEvent<
      TextChangedEvent.InputTuple,
      TextChangedEvent.OutputTuple,
      TextChangedEvent.OutputObject
    >;
    TextChanged: TypedContractEvent<
      TextChangedEvent.InputTuple,
      TextChangedEvent.OutputTuple,
      TextChangedEvent.OutputObject
    >;
  };
}
