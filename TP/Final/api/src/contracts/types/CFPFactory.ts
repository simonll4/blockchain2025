/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "./common";

export declare namespace CFPFactory {
  export type CallForProposalsStruct = {
    creator: AddressLike;
    cfp: AddressLike;
  };

  export type CallForProposalsStructOutput = [creator: string, cfp: string] & {
    creator: string;
    cfp: string;
  };
}

export interface CFPFactoryInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "owner"
      | "calls"
      | "allCallIds"
      | "creatorsCount"
      | "creators"
      | "createdBy"
      | "createdByCount"
      | "pendingCount"
      | "getPending"
      | "getAllPending"
      | "isRegistered"
      | "isAuthorized"
      | "create"
      | "createFor"
      | "registerProposal"
      | "register"
      | "authorize"
      | "unauthorize"
  ): FunctionFragment;

  getEvent(nameOrSignatureOrTopic: "CFPCreated"): EventFragment;

  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(functionFragment: "calls", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "allCallIds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "creatorsCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "creators",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createdBy",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createdByCount",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "pendingCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getPending",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getAllPending",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isRegistered",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isAuthorized",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "create",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createFor",
    values: [BytesLike, BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "registerProposal",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "register", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "authorize",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "unauthorize",
    values: [AddressLike]
  ): string;

  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "calls", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "allCallIds", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "creatorsCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "creators", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "createdBy", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "createdByCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "pendingCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getPending", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getAllPending",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isRegistered",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isAuthorized",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "create", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "createFor", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "registerProposal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "register", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "authorize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "unauthorize",
    data: BytesLike
  ): Result;
}

export namespace CFPCreatedEvent {
  export type InputTuple = [
    creator: AddressLike,
    callId: BytesLike,
    cfp: AddressLike
  ];
  export type OutputTuple = [creator: string, callId: string, cfp: string];
  export interface OutputObject {
    creator: string;
    callId: string;
    cfp: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface CFPFactory extends BaseContract {
  connect(runner?: ContractRunner | null): CFPFactory;
  waitForDeployment(): Promise<this>;

  interface: CFPFactoryInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  owner: TypedContractMethod<[], [string], "view">;

  calls: TypedContractMethod<
    [callId: BytesLike],
    [CFPFactory.CallForProposalsStructOutput],
    "view"
  >;

  allCallIds: TypedContractMethod<[], [string[]], "view">;

  creatorsCount: TypedContractMethod<[], [bigint], "view">;

  creators: TypedContractMethod<[index: BigNumberish], [string], "view">;

  /**
   * Devuelve el identificador del llamado que está en la posición `index` de la lista de llamados creados por `creator`
   */
  createdBy: TypedContractMethod<
    [creator: AddressLike, index: BigNumberish],
    [string],
    "view"
  >;

  createdByCount: TypedContractMethod<[creator: AddressLike], [bigint], "view">;

  pendingCount: TypedContractMethod<[], [bigint], "view">;

  getPending: TypedContractMethod<[index: BigNumberish], [string], "view">;

  getAllPending: TypedContractMethod<[], [string[]], "view">;

  isRegistered: TypedContractMethod<[account: AddressLike], [boolean], "view">;

  isAuthorized: TypedContractMethod<[account: AddressLike], [boolean], "view">;

  /**
   * Crea un llamado, con un identificador y un tiempo de cierre.  Si ya existe un llamado con ese identificador, revierte con el mensaje de error "El llamado ya existe"  Si el emisor no está autorizado a crear llamados, revierte con el mensaje "No autorizado"
   */
  create: TypedContractMethod<
    [callId: BytesLike, timestamp: BigNumberish],
    [string],
    "nonpayable"
  >;

  /**
   * Crea un llamado, estableciendo a `creator` como creador del mismo. Sólo puede ser invocada por el dueño de la factoría. Si el emisor no está autorizado a crear llamados, revierte con el mensaje "No autorizado"
   */
  createFor: TypedContractMethod<
    [callId: BytesLike, timestamp: BigNumberish, creator: AddressLike],
    [string],
    "nonpayable"
  >;

  /**
   * Permite a un usuario registrar una propuesta, para un llamado con identificador `callId`.  Si el llamado no existe, revierte con el mensaje "El llamado no existe".  Registra la propuesta en el llamado asociado con `callId` y pasa como creador la dirección del emisor del mensaje.
   */
  registerProposal: TypedContractMethod<
    [callId: BytesLike, proposal: BytesLike],
    [void],
    "nonpayable"
  >;

  /**
   * Permite que una cuenta se registre para poder crear llamados.  El registro queda en estado pendiente hasta que el dueño de la factoría lo autorice.  Si ya se ha registrado, revierte con el mensaje "Ya se ha registrado"
   */
  register: TypedContractMethod<[], [void], "nonpayable">;

  /**
   * Autoriza a una cuenta a crear llamados.  Sólo puede ser ejecutada por el dueño de la factoría.  En caso contrario revierte con el mensaje "Solo el creador puede hacer esta llamada".  Si la cuenta se ha registrado y está pendiente, la quita de la lista de pendientes,  si no la registra automáticamente.
   */
  authorize: TypedContractMethod<[creator: AddressLike], [void], "nonpayable">;

  /**
   * Quita la autorización de una cuenta para crear llamados. Sólo puede ser ejecutada por el dueño de la factoría. Si la cuenta está registrada y pendiente, la quita de pendientes. Siempre marca la cuenta como no autorizada y no registrada.
   */
  unauthorize: TypedContractMethod<
    [creator: AddressLike],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "owner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "calls"
  ): TypedContractMethod<
    [callId: BytesLike],
    [CFPFactory.CallForProposalsStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "allCallIds"
  ): TypedContractMethod<[], [string[]], "view">;
  getFunction(
    nameOrSignature: "creatorsCount"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "creators"
  ): TypedContractMethod<[index: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "createdBy"
  ): TypedContractMethod<
    [creator: AddressLike, index: BigNumberish],
    [string],
    "view"
  >;
  getFunction(
    nameOrSignature: "createdByCount"
  ): TypedContractMethod<[creator: AddressLike], [bigint], "view">;
  getFunction(
    nameOrSignature: "pendingCount"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "getPending"
  ): TypedContractMethod<[index: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "getAllPending"
  ): TypedContractMethod<[], [string[]], "view">;
  getFunction(
    nameOrSignature: "isRegistered"
  ): TypedContractMethod<[account: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "isAuthorized"
  ): TypedContractMethod<[account: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "create"
  ): TypedContractMethod<
    [callId: BytesLike, timestamp: BigNumberish],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "createFor"
  ): TypedContractMethod<
    [callId: BytesLike, timestamp: BigNumberish, creator: AddressLike],
    [string],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "registerProposal"
  ): TypedContractMethod<
    [callId: BytesLike, proposal: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "register"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "authorize"
  ): TypedContractMethod<[creator: AddressLike], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "unauthorize"
  ): TypedContractMethod<[creator: AddressLike], [void], "nonpayable">;

  getEvent(
    key: "CFPCreated"
  ): TypedContractEvent<
    CFPCreatedEvent.InputTuple,
    CFPCreatedEvent.OutputTuple,
    CFPCreatedEvent.OutputObject
  >;

  filters: {
    "CFPCreated(address,bytes32,address)": TypedContractEvent<
      CFPCreatedEvent.InputTuple,
      CFPCreatedEvent.OutputTuple,
      CFPCreatedEvent.OutputObject
    >;
    CFPCreated: TypedContractEvent<
      CFPCreatedEvent.InputTuple,
      CFPCreatedEvent.OutputTuple,
      CFPCreatedEvent.OutputObject
    >;
  };
}
